local ZombieAI = {}  -- The main table holding all the functions and data for the zombie AI system. I do this with a table so it's neatly organized, as a module, so it may be requested and utilized elsewhere without polluting the global scope.

local ServerStorage = game:GetService("ServerStorage")  -- Retrieving the ServerStorage service. We need this to use models like the zombie prefab held here.
local PathfindingService = game:GetService("PathfindingService")  -- PathfindingService is necessary for path calculation of zombies to navigate the world. We make extensive use of it for movement.
local Workspace = game:GetService("Workspace")  -- Workspace contains all game objects, so we access it for raycasting and zombie spawning.
local Terrain = Workspace.Terrain  -- Direct access to terrain for material checks like water. Avoids duplicate GetService calls for performance.
local NPCSound = require(game.ServerScriptService.Modules.NPCSound)  -- Having a module for sound effects. This separates sound logic, and code is modular and easier to maintain.

local CONFIG = {  -- All tweakable values. Having them in one place here makes it easy to modify without rummaging through code. I utilized a table instead of globals for namespacing.
	DetectionRange = 30,  -- How many zombies can perceive players. 30 studs is an even starting point; too high might make them too aggressive.
	ChaseAbandonRange = 50,  -- Chase distance where zombies discontinue pursuit. Higher than detection to prevent forever toggling.
	PatrolSpeed = 7,  -- Slower speed for patrolling to make zombies seem aimless rather than running.
	ChaseSpeed = 17,  -- Higher for running to create tension. Comparatively similar to standard player speeds in Roblox.
	AttackDamage = 15,  -- Damage per hit. Tuned for game; not too deadly but threatening.
	HealthRange = {50, 100},  -- Random health between 50-100 to provide zombies with a degree of variety.
	PatrolRadius = 25,  -- Zone around spawn to patrol. Wide enough for travel but limited.
	ReturnDistanceThreshold = 5,  -- How close to spawn to count returned. Small so it can reset properly.
	ExplosionRadius = 10,  -- Water explosion blast radius. Prevents it from radiating.
	ExplosionDamagePercent = 0.5,  -- Half health removed from explosion for equity.
	PatrolTimeout = 5,  -- Time before choosing new patrol point. Prevents repositioning excessively.
	JumpHeight = 12,  -- Max jump height in studs. Aligns Roblox humanoid ability.
	JumpStuckTimeout = 3,  -- Seconds stuck before jumping. Allows time to notice true stuck states.
	JumpHeightThreshold = 5,  -- Min height difference to jump. Avoids unnecessary jumps.
	JumpMovementThreshold = 0.75,  -- Min movement to avoid being stuck. Compensates for slight jitters.
	DescentHeightThreshold = 5,  -- Height to assume to be at an elevated position for descent. Prevents jumping off tiny ledges.
	EdgeDetectionDistance = 25,  -- How far to look forward for edges. Finds balance between performance and accuracy.
	MaxSlopeAngle = 30,  -- Max slope to walk. Based on practical terrain navigation.
	MinPatrolPointDelay = 2,  -- Min time to patrol swap. Prevents instant swapping.
	MinWaypointDistance = 4,  -- Min distance to accept waypoint as valid. Prevents micro-movements.
	MaxLOSDistance = 50,  -- Max line-of-sight distance. Not often used, but available for future addition.
	JumpCooldown = 3,  -- Chase jump cooldown. To avoid spamming.
	PatrolJumpCooldown = 5,  -- Patrol cooldown longer for a more realistic experience.
}

local zombieModel = ServerStorage:FindFirstChild("Sentinel")  -- Zombie model reference. Look up "Sentinel" in ServerStorage; this is under the assumption of pre-placing it there.
local activeZombies = {}  -- Table to manage live zombies for potential management such as cleaning up.
local spawnedZombies = {}  -- Spawns parts tracking to avoid duplicates. Utilizes parts as keys for quick access.
local rayParams = RaycastParams.new()  -- Raycast params setup. Omit Sentinel folder to avoid zombies raycasting themselves.
rayParams.FilterType = Enum.RaycastFilterType.Exclude
rayParams.FilterDescendantsInstances = {Workspace:FindFirstChild("Sentinel") or {}}

local function isWater(position)  -- Function to find out if position is in water. Uses terrain voxels for accuracy over raycasts since water may be very deep.
	local voxelSize = 4  -- Default Roblox voxel size for performance.
	local alignedPos = Vector3.new(  -- Snap to grid to read accurate voxel.
		math.floor(position.X / voxelSize) * voxelSize,
		math.floor(position.Y / voxelSize) * voxelSize,
		math.floor(position.Z / voxelSize) * voxelSize
	)
	local region = Region3.new(  -- Tiny area around position for checking.
		alignedPos - Vector3.new(voxelSize/2, voxelSize/2, voxelSize/2),
		alignedPos + Vector3.new(voxelSize/2, voxelSize/2, voxelSize/2)
	):ExpandToGrid(voxelSize)
	local materials = Terrain:ReadVoxels(region, voxelSize)[1]  -- Read one voxel.
	return materials and materials[1] and materials[1][1] == Enum.Material.Water  -- Check center for water material.
end

local function isWalkable(position)  -- Checks if position is walkable. Uses multiple offsets for robustness, as one point can be flaky on rough ground.
	local offsets = {  -- Offsets to sample about position for average.
		Vector3.new(0, 0, 0),
		Vector3.new(0.5, 0, 0), Vector3.new(-0.5, 0, 0),
		Vector3.new(0, 0, 0.5), Vector3.new(0, 0, -0.5),
	}
	local slopeAngles = {}  -- Collect angles from good samples.
	local isValid = false  -- Flag at least one good point.
	for _, offset in ipairs(offsets) do  -- Loop all offsets.
		local rayResult = Workspace:Raycast(position + Vector3.new(0, 50, 0) + offset, Vector3.new(0, -100, 0), rayParams)  -- Raycast down from above to check for surface.
		if not rayResult or not rayResult.Normal then continue end  -- Skip bad rays.
		local slopeAngle = math.deg(math.acos(rayResult.Normal.Y))  -- Calculate slope from normal.
		local isInvalidModel = rayResult.Instance and (rayResult.Instance.Name == "Mushroom2" or string.find(rayResult.Instance.Name:lower(), "tree"))  -- Check for bad models like trees/mushrooms that shouldn't be walked on.
		if slopeAngle <= CONFIG.MaxSlopeAngle and not isWater(rayResult.Position) and not isInvalidModel then  -- Valid if slope fine, not water, not bad.
			table.insert(slopeAngles, slopeAngle)  -- Add to averages.
			isValid = true
		end
	end
	if not isValid then return false, 0 end  -- No good points, not walkable.
	local avgSlope = 0  -- Sum for average.
	for _, angle in ipairs(slopeAngles) do avgSlope += angle end
	return true, avgSlope / #slopeAngles  -- Return valid and average slope.
end

local function isPathClear(startPos, endPos)  -- Raycast clear path. Added height to avoid ground clip.
	local direction = (endPos - startPos)  -- Direction vector.
	local rayResult = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), direction, rayParams)  -- Raycast slightly above ground.
	return not rayResult or (rayResult.Position - endPos).Magnitude < 1  -- Clear if hit not close to end or no hit.
end

local function hasObstacle(startPos, endPos)  -- Obstacle in front. 5 studs is close-range for immediate threat.
	local direction = (endPos - startPos).Unit * 5  -- Normalized short direction.
	local rayResult = Workspace:Raycast(startPos + Vector3.new(0, 2, 0), direction, rayParams)  -- Raycast forward from height.
	if not rayResult or not rayResult.Instance then return false, nil end  -- No obstacle.
	local isInvalidModel = rayResult.Instance.Name == "Mushroom2" or string.find(rayResult.Instance.Name:lower(), "tree")  -- Check hit avoidable like tree/mushroom.
	return not isInvalidModel, rayResult.Position  -- Return if real obstacle and pos.
end

local function getValidPatrolPosition(spawnPos, currentPos, zombie)  -- Finds valid patrol location. Tests large then small radius for best coverage first.
	if not spawnPos or not currentPos then return spawnPos or Vector3.new(0, 0, 0) end  -- Fallback if locations invalid.
	local attempts = {{CONFIG.PatrolRadius, 30}, {5, 15}}  -- Large radius more attempts, then small.
	for _, attempt in ipairs(attempts) do  -- Loop attempt set.
		local radius, maxTries = unpack(attempt)  -- Unpack values.
		for _ = 1, maxTries do  -- Attempt several times.
			local offset = Vector3.new(math.random(-radius, radius), 0, math.random(-radius, radius))  -- Random offset within radius.
			local newPos = spawnPos + offset  -- Possible position.
			local rayResult = Workspace:Raycast(newPos + Vector3.new(0, 50, 0), Vector3.new(0, -100, 0), rayParams)  -- Raycast downwards to ground.
			if not rayResult then continue end  -- No ground, skip.
			local isWalkablePoint, slopeAngle = isWalkable(rayResult.Position)  -- Check walkable and flat.
			if isWalkablePoint and slopeAngle <= 5 and isPathClear(currentPos, rayResult.Position) then  -- Extra clear path check.
				local path = PathfindingService:CreatePath()  -- Check with full path.
				path:ComputeAsync(currentPos, rayResult.Position)
				if path.Status == Enum.PathStatus.Success then
					return rayResult.Position  -- Valid path, return.
				end
			end
		end
	end
	return spawnPos  -- Fallback to spawn if none valid found.
end

local function findDescentPosition(currentPos)  -- Look for ground below to descend. Various directions for greater probability of finding way below.
	local directions = {  -- 8 directions for full coverage.
		Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0),
		Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
		Vector3.new(1, 0, 1).Unit, Vector3.new(-1, 0, -1).Unit,
		Vector3.new(1, 0, -1).Unit, Vector3.new(-1, 0, 1).Unit,
	}
	local bestDescentPos, minDistanceToGround = nil, math.huge  -- Best option track.
	for _, direction in ipairs(directions) do  -- For each direction.
		for distance = 1, CONFIG.EdgeDetectionDistance do  -- Incremental steps.
			local checkPos = currentPos + direction * distance  -- Position where to check.
			local rayResult = Workspace:Raycast(checkPos + Vector3.new(0, 5, 0), Vector3.new(0, -50, 0), rayParams)  -- Raycast downwards.
			if not rayResult then continue end  -- No collision.
			local heightDifference = currentPos.Y - rayResult.Position.Y  -- Drop height.
			if heightDifference > 0 and heightDifference <= CONFIG.JumpHeight * 1.5 and heightDifference < minDistanceToGround then  -- Valid if drop is in jump range and better than existing.
				bestDescentPos = checkPos
				minDistanceToGround = heightDifference
			end
		end
	end
	return bestDescentPos  -- Best discovered or null.
end

local function findClimbPosition(currentPos, targetPos)  -- Descent equivalent but for moving up. Small steps for precision.
	local directions = {  -- Same directions.
		Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0),
		Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
		Vector3.new(1, 0, 1).Unit, Vector3.new(-1, 0, -1).Unit,
		Vector3.new(1, 0, -1).Unit, Vector3.new(-1, 0, 1).Unit,
	}
	local bestClimbPos, minDistanceToTarget = nil, math.huge  -- Closest track.
	for _, direction in ipairs(directions) do
		for distance = 0.3, CONFIG.EdgeDetectionDistance, 0.3 do  -- Smaller steps.
			local checkPos = currentPos + direction * distance
			local rayResult = Workspace:Raycast(checkPos + Vector3.new(0, 50, 0), Vector3.new(0, -100, 0), rayParams)  -- Raycast to surface.
			if not rayResult then continue end
			local surfacePos = rayResult.Position
			local heightDifference = targetPos.Y - surfacePos.Y  -- Climb height.
			local horizontalDistance = (Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(surfacePos.X, 0, surfacePos.Z)).Magnitude  -- Horizontal range to target.
			if heightDifference > 0 and heightDifference <= CONFIG.JumpHeight and horizontalDistance < minDistanceToTarget then  -- Valid if climbable and nearer.
				if isWalkable(surfacePos) then  -- Make traversable.
					bestClimbPos = surfacePos
					minDistanceToTarget = horizontalDistance
				end
			end
		end
	end
	if not bestClimbPos then  -- Fall back to horizontal projection if no climb.
		local closestPos = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
		if isWalkable(closestPos) then return closestPos end
	end
	return bestClimbPos
end

local function isElevated(position)  -- Indicates if elevated. Additional offsets for completeness on rough ground.
	local offsets = {  -- Bigger offsets for better detection.
		Vector3.new(0, 0, 0),
		Vector3.new(0.5, 0, 0), Vector3.new(-0.5, 0, 0),
		Vector3.new(0, 0, 0.5), Vector3.new(0, 0, -0.5),
		Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0),
		Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
	}
	for _, offset in ipairs(offsets) do
		local rayResult = Workspace:Raycast(position + Vector3.new(0, 5, 0) + offset, Vector3.new(0, -50, 0), rayParams)  -- Raycast down.
		if not rayResult then continue end
		local heightDifference = position.Y - rayResult.Position.Y  -- Drop.
		return heightDifference > CONFIG.DescentHeightThreshold, rayResult.Instance  -- Back if above threshold.
	end
	return false, nil  -- Not on a height.
end

local function getSmoothedTargetPosition(target, lastTargetPos)  -- Interpolates target position with lerp for smoother motion.
	if not target or not target.HumanoidRootPart then return lastTargetPos end  -- Fall back if invalid.
	local currentPos = target.HumanoidRootPart.Position
	return lastTargetPos and lastTargetPos:Lerp(currentPos, 0.3) or currentPos  -- Lerp 0.3 for medium smoothing but not too much lag.
end

local function handleWater(zombie, state, humanoid, rootPart, zombieSpawnPart)  -- Handling water contact: explode, damage, respawn. Water as weakness adds gameplay mechanism.
	if not isWater(rootPart.Position) then return false end  -- Not in water.
	local explosion = Instance.new("Explosion")  -- Spawn explosion effect.
	explosion.Position = rootPart.Position
	explosion.BlastRadius = CONFIG.ExplosionRadius
	explosion.BlastPressure = 20  -- Gentle pressure.
	explosion.DestroyJointRadiusPercent = 0  -- No break of joint.
	explosion.ExplosionType = Enum.ExplosionType.NoCraters  -- Performance, no change of terrain.
	explosion.Parent = Workspace
	explosion.Hit:Connect(function(part)  -- Hit event for damage.
		local playerHumanoid = part.Parent:FindFirstChildOfClass("Humanoid")
		if playerHumanoid and playerHumanoid ~= humanoid then  -- Not self.
			local distance = (part.Position - explosion.Position).Magnitude
			if distance <= CONFIG.ExplosionRadius then  -- In range.
				playerHumanoid:TakeDamage(playerHumanoid.Health * CONFIG.ExplosionDamagePercent)
			end
		end
	end)
	NPCSound:StopSounds(zombie)  -- Stop death sounds.
	local index = table.find(activeZombies, zombie)  -- Remove from active list.
	if index then table.remove(activeZombies, index) end
	for spawnPart, _ in pairs(spawnedZombies) do  -- Clear spawned flag set.
		if (spawnPart.Position - zombieSpawnPart.Position).Magnitude < 1 then
			spawnedZombies[spawnPart] = nil
			break
		end
	end
	zombie:Destroy()  -- Kill zombie.
	ZombieAI:SpawnZombieAt(zombieSpawnPart)  -- Respawn immediately.
	return true  -- Handled.
end

local function handleTargetSelection(state, rootPart, humanoid, zombie)  -- Selects target if none. Loops players, chooses closest in range.
	if state.currentTarget then return end  -- Target already available.
	for _, player in ipairs(game.Players:GetPlayers()) do  -- All players are present.
		if not player.Character or not player.Character.Humanoid or player.Character.Humanoid.Health <= 0 then continue end  -- Ignore invalid.
		local distance = (player.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
		if distance <= CONFIG.DetectionRange then  -- In range.
			state.currentTarget = player.Character  -- Set target to.
			humanoid.WalkSpeed = CONFIG.ChaseSpeed  -- Speed up movement.
			state.returningToSpawn = false  -- Reset chase mode states.
			state.lastPatrolPos = nil
			state.patrolTimer = 0
			state.stuckTimer = 0
			state.stuckCount = 0
			state.descentTarget = nil
			state.climbTarget = nil
			state.currentWaypointIndex = 1
			state.cachedWaypoints = nil
			state.lastTargetPos = nil
			state.lastPathUpdate = 0
			state.jumpState.shouldJump = false
			state.jumpState.reason = nil
			humanoid.Jump = false
			state.lastJumpTime = 0
			state.jumpAttempts = 0
			NPCSound:PlayChaseSound(zombie)  -- Sound cue activate.
			break  -- First one encountered, don't need closest yet.
		end
	end
end

local function abandonChase(state, humanoid, zombie)  -- Assistant to abandon chase and reset.
	state.currentTarget = nil
	humanoid.WalkSpeed = CONFIG.PatrolSpeed
	humanoid:Move(Vector3.new(0, 0, 0), false)
	state.returningToSpawn = true
	state.lastPatrolPos = nil
	state.patrolTimer = 0
	state.stuckTimer = 0
	state.stuckCount = 0
	state.descentTarget = nil
	state.climbTarget = nil
	state.losTimer = nil
	state.currentWaypointIndex = 1
	state.cachedWaypoints = nil
	state.lastTargetPos = nil
	state.lastPathUpdate = 0
	state.jumpState.shouldJump = false
	state.jumpState.reason = nil
	humanoid.Jump = false
	state.lastJumpTime = 0
	state.jumpAttempts = 0
	NPCSound:StopSounds(zombie)
end

local function getEffectiveTargetPos(targetPos, rootPart)  -- Receives adjusted target pos for elevation or invalid walk check.
	local isTargetElevated, targetInstance = isElevated(targetPos)  -- Check if high target.
	local effectiveTargetPos = targetPos
	if isTargetElevated then  -- If high, shoot at ground beneath target.
		local rayResult = Workspace:Raycast(targetPos + Vector3.new(0, 5, 0), Vector3.new(0, -50, 0), rayParams)
		if rayResult then
			effectiveTargetPos = Vector3.new(targetPos.X, rayResult.Position.Y + 0.1, targetPos.Z)  -- Slight offset above ground level.
		end
	end
	local isValidTarget = isWalkable(effectiveTargetPos)  -- Check walkable.
	if not isValidTarget then  -- If not, stay at same height.
		effectiveTargetPos = Vector3.new(effectiveTargetPos.X, rootPart.Position.Y, effectiveTargetPos.Z)
	end
	return effectiveTargetPos
end

local function handleClimb(state, humanoid, rootPart, targetPos)  -- Controls climb to high target.
	if state.climbTarget then return false end  -- Already climbing.
	state.climbTarget = findClimbPosition(rootPart.Position, targetPos)
	if not state.climbTarget then return false end  -- No climb spot.
	local direction = (state.climbTarget - rootPart.Position).Unit * humanoid.WalkSpeed  -- Move to climb spot.
	humanoid:Move(direction, false)
	local heightDifference = targetPos.Y - rootPart.Position.Y  -- Height test.
	if heightDifference > CONFIG.JumpHeightThreshold and heightDifference <= CONFIG.JumpHeight and tick() - state.lastJumpTime >= CONFIG.JumpCooldown and (rootPart.Position - state.climbTarget).Magnitude < 4 then  -- Jump if needed and conditions valid.
		state.jumpState.shouldJump = true
		state.jumpState.reason = "Climbing to reach player"
	end
	if (rootPart.Position - state.climbTarget).Magnitude < 4 then  -- Reset if close.
		state.climbTarget = nil
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	end
	return true  -- Handled climb.
end

local function computePathTo(effectiveTargetPos, rootPart)  -- Computes path, tries offsets if fail.
	local path = PathfindingService:CreatePath()
	path:ComputeAsync(rootPart.Position, effectiveTargetPos)
	if path.Status == Enum.PathStatus.Success then return path end  -- Good path.
	local offsets = {  -- Try nearby positions.
		Vector3.new(5, 0, 0), Vector3.new(-5, 0, 0),
		Vector3.new(0, 0, 5), Vector3.new(0, 0, -5),
		Vector3.new(3, 0, 3), Vector3.new(-3, 0, -3),
		Vector3.new(7, 0, 0), Vector3.new(-7, 0, 0),
		Vector3.new(0, 0, 7), Vector3.new(0, 0, -7),
	}
	for _, offset in ipairs(offsets) do
		local altPos = effectiveTargetPos + offset
		if not isWalkable(altPos) then continue end  -- Skip bogus.
		path:ComputeAsync(rootPart.Position, altPos)
		if path.Status == Enum.PathStatus.Success then
			local waypoints = path:GetWaypoints()
			if #waypoints > 1 then return path end  -- Valid alternative.
		end
	end
	return nil  -- No path.
end

local function handleDescent(state, humanoid, rootPart, heightDifferenceToTarget)  -- Controls descent in chase.
	if heightDifferenceToTarget <= CONFIG.DescentHeightThreshold or state.descentTarget or state.climbTarget then
		state.descentTarget = nil
		return false
	end
	state.descentTarget = findDescentPosition(rootPart.Position)
	if not state.descentTarget then return false end
	local direction = (state.descentTarget - rootPart.Position).Unit * humanoid.WalkSpeed
	humanoid:Move(direction, false)
	state.jumpState.shouldJump = true
	state.jumpState.reason = "Jumping down to chase"
	if (rootPart.Position - state.descentTarget).Magnitude < 1 then
		state.descentTarget = nil
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	end
	return true
end

local function updateStuckState(state, humanoid, rootPart, movedDistance, nextWaypoint, effectiveTargetPos, hasObstacleFlag)  -- Resets stuck logic for chase.
	if movedDistance >= CONFIG.JumpMovementThreshold then  -- Moving fine.
		state.stuckTimer = 0
		state.stuckCount = 0
		return
	end
	state.stuckTimer += 0.05  -- Increment timer.
	if state.stuckTimer < CONFIG.JumpStuckTimeout then return end  -- Not stuck yet.
	state.stuckCount += 1  -- Count up.
	local isElevatedFlag, hitInstance = isElevated(rootPart.Position)
	local onAvoidableModel = hitInstance and (hitInstance.Name == "Mushroom2" or string.find(hitInstance.Name:lower(), "tree"))
	if state.stuckCount >= 12 and onAvoidableModel then  -- Stuck on avoidable, descend.
		state.descentTarget = findDescentPosition(rootPart.Position)
		if not state.descentTarget then
			local path = PathfindingService:CreatePath()
			path:ComputeAsync(rootPart.Position, effectiveTargetPos)  -- Recompute.
			state.currentWaypointIndex = 1
		end
		state.stuckTimer = 0
		state.stuckCount = 0
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	elseif state.stuckCount >= 12 and hasObstacleFlag then  -- Obstacle stuck, recompute and jump.
		local path = PathfindingService:CreatePath()
		path:ComputeAsync(rootPart.Position, effectiveTargetPos)
		state.currentWaypointIndex = 1
		state.stuckTimer = 0
		state.stuckCount = 0
		if tick() - state.lastJumpTime >= CONFIG.JumpCooldown then
			state.jumpState.shouldJump = true
			state.jumpState.reason = "Stuck, so jumping"
		end
	else
		state.stuckTimer = 0  -- Reset timer.
	end
end

local function handleChase(zombie, state, humanoid, rootPart)  -- Main chase function. Broken into helpers to prevent nesting.
	if not state.currentTarget then return false end  -- No target.
	local targetPos = getSmoothedTargetPosition(state.currentTarget, state.lastTargetPos)
	state.lastTargetPos = targetPos
	local distanceToTarget = (targetPos - rootPart.Position).Magnitude
	local targetInWater = isWater(targetPos)
	if not state.currentTarget.Humanoid or state.currentTarget.Humanoid.Health <= 0 or distanceToTarget > CONFIG.ChaseAbandonRange or targetInWater then  -- Abandon if conditions fulfilled.
		abandonChase(state, humanoid, zombie)
		return false
	end
	local isTargetElevated = isElevated(targetPos)  -- Check elevation.
	if isTargetElevated and handleClimb(state, humanoid, rootPart, targetPos) then return true end  -- Handle climb.
	local effectiveTargetPos = getEffectiveTargetPos(targetPos, rootPart)  -- Adjust pos.
	if distanceToTarget <= 5 then  -- Close enough to attack.
		state.currentTarget.Humanoid:TakeDamage(CONFIG.AttackDamage)
	end
	if tick() - state.lastPathUpdate < 0.5 then return true end  -- Throttle updates.
	local path = computePathTo(effectiveTargetPos, rootPart)  -- Get path.
	if not path then  -- No path, fallback move or jump.
		local horizontalTargetPos = Vector3.new(targetPos.X, rootPart.Position.Y, targetPos.Z)
		local direction = (horizontalTargetPos - rootPart.Position).Unit * humanoid.WalkSpeed
		if (horizontalTargetPos - rootPart.Position).Magnitude > 4 then
			humanoid:Move(direction, false)
		elseif tick() - state.lastJumpTime >= CONFIG.JumpCooldown and state.jumpAttempts < 3 then
			state.jumpState.shouldJump = true
			state.jumpState.reason = "No path, trying a jump"
			state.jumpAttempts += 1
		end
		state.stuckTimer = 0
		state.stuckCount = 0
		return true
	end
	local waypoints = path:GetWaypoints()
	if #waypoints <= 1 then  -- Invalid waypoints, halt.
		humanoid:Move(Vector3.new(0, 0, 0), false)
		state.stuckTimer = 0
		state.stuckCount = 0
		return true
	end
	local nextWaypoint = waypoints[2].Position
	local isWaypointElevated, waypointInstance = isElevated(nextWaypoint)
	local isWaypointOnAvoidableModel = waypointInstance and (waypointInstance.Name == "Mushroom2" or string.find(waypointInstance.Name:lower(), "tree"))
	if isWaypointOnAvoidableModel then
		state.currentWaypointIndex = 1
		path:ComputeAsync(rootPart.Position, effectiveTargetPos)
		waypoints = path:GetWaypoints()
		if #waypoints <= 1 then
			humanoid:Move(Vector3.new(0, 0, 0), false)
			state.stuckTimer = 0
			state.stuckCount = 0
			return true
		end
		nextWaypoint = waypoints[2].Position
	end
	if isWater(nextWaypoint) or not isPathClear(rootPart.Position, nextWaypoint) then return true end  -- Bad waypoint, skip.
	local heightDifferenceToTarget = targetPos.Y - rootPart.Position.Y
	if handleDescent(state, humanoid, rootPart, heightDifferenceToTarget) then return true end
	local heightDifference = nextWaypoint.Y - rootPart.Position.Y
	local isWalkableWaypoint, slopeAngle = isWalkable(nextWaypoint)
	local hasObstacleFlag = hasObstacle(rootPart.Position, nextWaypoint)
	if ((heightDifference > CONFIG.JumpHeightThreshold and heightDifference <= CONFIG.JumpHeight) or (isWalkableWaypoint and slopeAngle > 45)) and hasObstacleFlag and tick() - state.lastJumpTime >= CONFIG.JumpCooldown then  -- Jump conditions.
		state.jumpState.shouldJump = true
		state.jumpState.reason = "Jumping over stuff"
	end
	local movedDistance = (rootPart.Position - state.lastPosition).Magnitude
	updateStuckState(state, humanoid, rootPart, movedDistance, nextWaypoint, effectiveTargetPos, hasObstacleFlag)  -- Update stuck.
	local direction = (nextWaypoint - rootPart.Position).Unit * humanoid.WalkSpeed
	humanoid:Move(direction, false)  -- Move.
	state.lastPathUpdate = tick()
	return true
end

local function handleDescentToSpawn(state, humanoid, rootPart, heightDifferenceToSpawn)  -- Descent for return to spawn. Inverted height since returning.
	if heightDifferenceToSpawn <= CONFIG.DescentHeightThreshold or state.descentTarget then
		state.descentTarget = nil
		return false
	end
	state.descentTarget = findDescentPosition(rootPart.Position)
	if not state.descentTarget then return false end
	local direction = (state.descentTarget - rootPart.Position).Unit * CONFIG.PatrolSpeed
	humanoid:Move(direction, false)
	state.jumpState.shouldJump = true
	state.jumpState.reason = "Jumping down to spawn"
	if (rootPart.Position - state.descentTarget).Magnitude < 1 then
		state.descentTarget = nil
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	end
	return true
end

local function updateStuckStateForReturn(state, humanoid, rootPart, movedDistance, spawnPos, hasObstacleFlag)  -- Stuck update for return.
	if movedDistance >= CONFIG.JumpMovementThreshold then
		state.stuckTimer = 0
		state.stuckCount = 0
		return
	end
	state.stuckTimer += 0.05
	if state.stuckTimer < CONFIG.JumpStuckTimeout then return end
	state.stuckCount += 1
	local isElevatedFlag, hitInstance = isElevated(rootPart.Position)
	local onAvoidableModel = hitInstance and (hitInstance.Name == "Mushroom2" or string.find(hitInstance.Name:lower(), "tree"))
	if state.stuckCount >= 15 and onAvoidableModel then  -- Patrol/return higher threshold to reduce jumps.
		state.descentTarget = findDescentPosition(rootPart.Position)
		if not state.descentTarget then
			local path = PathfindingService:CreatePath()
			path:ComputeAsync(rootPart.Position, spawnPos)
			state.currentWaypointIndex = 1
		end
		state.stuckTimer = 0
		state.stuckCount = 0
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	elseif state.stuckCount >= 15 and hasObstacleFlag then
		local path = PathfindingService:CreatePath()
		path:ComputeAsync(rootPart.Position, spawnPos)
		state.currentWaypointIndex = 1
		state.stuckTimer = 0
		state.stuckCount = 0
		if tick() - state.lastJumpTime >= CONFIG.PatrolJumpCooldown then
			state.jumpState.shouldJump = true
			state.jumpState.reason = "Stuck, so jumping"
		end
	else
		state.stuckTimer = 0
	end
end

local function handleReturnToSpawn(zombie, state, humanoid, rootPart, spawnPos)  -- Spawn return logic.
	if state.currentTarget then return false end
	local distanceToSpawn = (rootPart.Position - spawnPos).Magnitude
	if not state.returningToSpawn or distanceToSpawn <= CONFIG.ReturnDistanceThreshold then return false end
	if tick() - state.lastPathUpdate < 0.5 then return true end
	local path = PathfindingService:CreatePath()
	path:ComputeAsync(rootPart.Position, spawnPos)
	if path.Status ~= Enum.PathStatus.Success then
		humanoid:Move(Vector3.new(0, 0, 0), false)
		state.stuckTimer = 0
		state.stuckCount = 0
		return true
	end
	local waypoints = path:GetWaypoints()
	if #waypoints <= 1 then
		humanoid:Move(Vector3.new(0, 0, 0), false)
		state.stuckTimer = 0
		state.stuckCount = 0
		return true
	end
	local nextWaypoint = waypoints[2].Position
	local isWaypointElevated, waypointInstance = isElevated(nextWaypoint)
	local isWaypointOnAvoidableModel = waypointInstance and (waypointInstance.Name == "Mushroom2" or string.find(waypointInstance.Name:lower(), "tree"))
	if isWaypointOnAvoidableModel then
		state.currentWaypointIndex = 1
		path:ComputeAsync(rootPart.Position, spawnPos)
		waypoints = path:GetWaypoints()
		if #waypoints <= 1 then
			humanoid:Move(Vector3.new(0, 0, 0), false)
			state.stuckTimer = 0
			state.stuckCount = 0
			return true
		end
		nextWaypoint = waypoints[2].Position
	end
	if isWater(nextWaypoint) or not isPathClear(rootPart.Position, nextWaypoint) then return true end
	local heightDifferenceToSpawn = rootPart.Position.Y - spawnPos.Y
	if handleDescentToSpawn(state, humanoid, rootPart, heightDifferenceToSpawn) then return true end
	local heightDifference = nextWaypoint.Y - rootPart.Position.Y
	local isWalkableWaypoint, slopeAngle = isWalkable(nextWaypoint)
	local hasObstacleFlag = hasObstacle(rootPart.Position, nextWaypoint)
	if ((heightDifference > 7 and heightDifference <= CONFIG.JumpHeight) or (isWalkableWaypoint and slopeAngle > 50)) and hasObstacleFlag and tick() - state.lastJumpTime >= CONFIG.PatrolJumpCooldown then
		state.jumpState.shouldJump = true
		state.jumpState.reason = "Jumping over terrain"
	end
	local movedDistance = (rootPart.Position - state.lastPosition).Magnitude
	updateStuckStateForReturn(state, humanoid, rootPart, movedDistance, spawnPos, hasObstacleFlag)
	local direction = (nextWaypoint - rootPart.Position).Unit * CONFIG.PatrolSpeed
	humanoid:Move(direction, false)
	state.lastPathUpdate = tick()
	return true
end

local function updateStuckStateForPatrol(state, humanoid, rootPart, movedDistance, spawnPos, hasObstacleFlag)  -- Stuck update for patrol.
	if movedDistance >= CONFIG.JumpMovementThreshold then
		state.stuckTimer = 0
		state.stuckCount = 0
		return
	end
	state.stuckTimer += 0.05
	if state.stuckTimer < CONFIG.JumpStuckTimeout then return end
	state.stuckCount += 1
	local isElevatedFlag, hitInstance = isElevated(rootPart.Position)
	local onAvoidableModel = hitInstance and (hitInstance.Name == "Mushroom2" or string.find(hitInstance.Name:lower(), "tree"))
	if state.stuckCount >= 15 and onAvoidableModel then
		state.descentTarget = findDescentPosition(rootPart.Position)
		if not state.descentTarget then
			state.lastPatrolPos = getValidPatrolPosition(spawnPos, rootPart.Position, zombie)
			state.currentWaypointIndex = 1
			state.cachedWaypoints = nil
		end
		state.stuckTimer = 0
		state.stuckCount = 0
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	elseif state.stuckCount >= 15 and hasObstacleFlag then
		state.lastPatrolPos = getValidPatrolPosition(spawnPos, rootPart.Position, zombie)
		state.currentWaypointIndex = 1
		state.cachedWaypoints = nil
		state.stuckTimer = 0
		state.stuckCount = 0
		if tick() - state.lastJumpTime >= CONFIG.PatrolJumpCooldown then
			state.jumpState.shouldJump = true
			state.jumpState.reason = "Stuck, so jumping"
		end
	else
		state.stuckTimer = 0
	end
end

local function handlePatrol(zombie, state, humanoid, rootPart, spawnPos)  -- Patrol logic.
	if state.currentTarget or state.returningToSpawn then return false end  -- Not patrolling.
	state.patrolTimer += 0.05  -- Timer increment.
	NPCSound:PlayPatrolSound(zombie)  -- Sound for immersion.
	local currentTime = tick()
	if not state.lastPatrolPos or state.patrolTimer >= CONFIG.PatrolTimeout then  -- Pick new point if needed.
		if currentTime - state.lastPatrolChangeTime >= CONFIG.MinPatrolPointDelay then
			state.lastPatrolPos = getValidPatrolPosition(spawnPos, rootPart.Position, zombie)
			state.patrolTimer = 0
			state.lastPatrolChangeTime = currentTime
			state.currentWaypointIndex = 1
			state.cachedWaypoints = nil
			state.stuckCount = 0
			state.jumpState.shouldJump = false
			state.jumpState.reason = nil
			humanoid.Jump = false
			state.lastJumpTime = 0
			state.jumpAttempts = 0
		end
	end
	if not state.lastPatrolPos then
		humanoid:Move(Vector3.new(0, 0, 0), false)
		return true
	end
	if not state.cachedWaypoints or tick() - state.lastPathUpdate >= 0.5 then  -- Cache or compute path.
		local path = PathfindingService:CreatePath()
		path:ComputeAsync(rootPart.Position, state.lastPatrolPos)
		if path.Status ~= Enum.PathStatus.Success then
			state.lastPatrolPos = getValidPatrolPosition(spawnPos, rootPart.Position, zombie)
			state.currentWaypointIndex = 1
			state.cachedWaypoints = nil
			humanoid:Move(Vector3.new(0, 0, 0), false)
			return true
		end
		state.cachedWaypoints = path:GetWaypoints()
		state.lastPathUpdate = tick()
	end
	if not state.cachedWaypoints or #state.cachedWaypoints <= state.currentWaypointIndex then
		if state.lastPatrolPos and (rootPart.Position - state.lastPatrolPos).Magnitude < 3 then
			state.lastPatrolPos = nil
			state.patrolTimer = CONFIG.PatrolTimeout
			state.currentWaypointIndex = 1
			state.cachedWaypoints = nil
			state.stuckCount = 0
			state.jumpState.shouldJump = false
			state.jumpState.reason = nil
			humanoid.Jump = false
			state.lastJumpTime = 0
			state.jumpAttempts = 0
		end
		return true
	end
	local nextWaypoint = state.cachedWaypoints[state.currentWaypointIndex].Position
	local isWaypointElevated, waypointInstance = isElevated(nextWaypoint)
	local isWaypointOnAvoidableModel = waypointInstance and (waypointInstance.Name == "Mushroom2" or string.find(waypointInstance.Name:lower(), "tree"))
	if isWaypointOnAvoidableModel then
		state.lastPatrolPos = getValidPatrolPosition(spawnPos, rootPart.Position, zombie)
		state.currentWaypointIndex = 1
		state.cachedWaypoints = nil
		return true
	end
	if isWater(nextWaypoint) or (nextWaypoint - rootPart.Position).Magnitude < CONFIG.MinWaypointDistance or not isPathClear(rootPart.Position, nextWaypoint) then  -- Bad waypoint, skip.
		state.currentWaypointIndex += 1
		return true
	end
	local heightDifference = nextWaypoint.Y - rootPart.Position.Y
	local isWalkableWaypoint, slopeAngle = isWalkable(nextWaypoint)
	local hasObstacleFlag = hasObstacle(rootPart.Position, nextWaypoint)
	if ((heightDifference > 7 and heightDifference <= CONFIG.JumpHeight) or (isWalkableWaypoint and slopeAngle > 50)) and hasObstacleFlag and tick() - state.lastJumpTime >= CONFIG.PatrolJumpCooldown then  -- Jump conditions.
		state.jumpState.shouldJump = true
		state.jumpState.reason = "Jumping over terrain"
	end
	local movedDistance = (rootPart.Position - state.lastPosition).Magnitude
	updateStuckStateForPatrol(state, humanoid, rootPart, movedDistance, spawnPos, hasObstacleFlag)  -- Update stuck.
	local direction = (nextWaypoint - rootPart.Position).Unit * CONFIG.PatrolSpeed
	humanoid:Move(direction, false)
	if (rootPart.Position - nextWaypoint).Magnitude < 3 then
		state.currentWaypointIndex += 1  -- Progress.
	end
	return true
end

local function handleInvalidModel(state, humanoid, rootPart)  -- Handles getting off bad models.
	local isElevatedFlag, hitInstance = isElevated(rootPart.Position)
	local onAvoidableModel = hitInstance and (hitInstance.Name == "Mushroom2" or string.find(hitInstance.Name:lower(), "tree"))
	if not onAvoidableModel or state.descentTarget then return false end
	state.descentTarget = findDescentPosition(rootPart.Position)
	if not state.descentTarget then return false end
	local direction = (state.descentTarget - rootPart.Position).Unit * humanoid.WalkSpeed
	humanoid:Move(direction, false)
	state.jumpState.shouldJump = true
	state.jumpState.reason = "Jumping off tree or mushroom"
	if (rootPart.Position - state.descentTarget).Magnitude < 1 then
		state.descentTarget = nil
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
	end
	return true
end

function ZombieAI:SpawnZombieAt(zombieSpawnPart)  -- Spawn function.
	if not zombieModel or not zombieSpawnPart then return end
	if spawnedZombies[zombieSpawnPart] then return end  -- No duplicate.
	local zombie = zombieModel:Clone()
	local humanoid = zombie.Humanoid
	humanoid.WalkSpeed = CONFIG.PatrolSpeed
	humanoid.HipHeight = 2  -- Standard for Roblox characters.
	humanoid.JumpPower = CONFIG.JumpHeight * 5  -- Magnified for good jumps.
	humanoid.AutoJumpEnabled = true  -- Roblox handles auto jumps.
	humanoid.Health = math.random(CONFIG.HealthRange[1], CONFIG.HealthRange[2])
	zombie:PivotTo(zombieSpawnPart.CFrame)  -- Spawn at place.
	zombie.Parent = Workspace
	spawnedZombies[zombieSpawnPart] = true
	table.insert(activeZombies, zombie)
	local initialPatrolPos = getValidPatrolPosition(zombieSpawnPart.Position, zombie.HumanoidRootPart.Position, zombie)
	task.spawn(function() self:StartZombieAI(zombie, zombieSpawnPart, initialPatrolPos) end)  -- Async AI start.
end

function ZombieAI:StartZombieAI(zombie, zombieSpawnPart, initialPatrolPos)  -- Main AI loop.
	local humanoid = zombie.Humanoid
	local rootPart = zombie.HumanoidRootPart
	local spawnPos = zombieSpawnPart.Position
	local state = {  -- State init.
		currentTarget = nil,
		returningToSpawn = false,
		lastPatrolPos = initialPatrolPos,
		patrolTimer = 0,
		lastPosition = rootPart.Position,
		stuckTimer = 0,
		stuckCount = 0,
		descentTarget = nil,
		climbTarget = nil,
		losTimer = nil,
		lastPatrolChangeTime = 0,
		currentWaypointIndex = 1,
		cachedWaypoints = nil,
		lastJumpTime = 0,
		jumpState = {shouldJump = false, reason = nil},
		lastTargetPos = nil,
		lastPathUpdate = 0,
		jumpAttempts = 0
	}
	while humanoid.Health > 0 do  -- Loop till dead.
		if handleWater(zombie, state, humanoid, rootPart, zombieSpawnPart) then break end  -- Water check first.
		if handleInvalidModel(state, humanoid, rootPart) then
			state.lastPosition = rootPart.Position
			task.wait(0.05)
			continue
		end
		handleTargetSelection(state, rootPart, humanoid, zombie)  -- Target search.
		if handleChase(zombie, state, humanoid, rootPart) then
			if state.jumpState.shouldJump and tick() - state.lastJumpTime >= CONFIG.JumpCooldown then
				humanoid.Jump = true
				state.lastJumpTime = tick()
			else
				humanoid.Jump = false
			end
			state.lastPosition = rootPart.Position
			task.wait(0.05)
			continue
		end
		if handleReturnToSpawn(zombie, state, humanoid, rootPart, spawnPos) then
			if state.jumpState.shouldJump and tick() - state.lastJumpTime >= CONFIG.PatrolJumpCooldown then
				humanoid.Jump = true
				state.lastJumpTime = tick()
			else
				humanoid.Jump = false
			end
			state.lastPosition = rootPart.Position
			task.wait(0.05)
			continue
		end
		if handlePatrol(zombie, state, humanoid, rootPart, spawnPos) then
			if state.jumpState.shouldJump and tick() - state.lastJumpTime >= CONFIG.PatrolJumpCooldown then
				humanoid.Jump = true
				state.lastJumpTime = tick()
			else
				humanoid.Jump = false
			end
			state.lastPosition = rootPart.Position
			task.wait(0.05)
			continue
		end
		humanoid:Move(Vector3.new(0, 0, 0), false)  -- Fallback stop.
		state.jumpState.shouldJump = false
		state.jumpState.reason = nil
		humanoid.Jump = false
		state.lastJumpTime = 0
		state.jumpAttempts = 0
		state.lastPosition = rootPart.Position
		task.wait(0.05)
	end
end

function ZombieAI:Init()  -- Init spawns at all points.
	local zombieSpawnParts = {}
	for _, part in ipairs(Workspace:GetChildren()) do
		if part.Name == "ZombieSpawn" then
			table.insert(zombieSpawnParts, part)
		end
	end
	spawnedZombies = {}
	activeZombies = {}
	for _, zombieSpawnPart in ipairs(zombieSpawnParts) do
		self:SpawnZombieAt(zombieSpawnPart)
	end
end

return ZombieAI
